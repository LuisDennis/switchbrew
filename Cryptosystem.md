Like the 3DS, the Switch relies on a number of cryptographic keys to
prevent unauthorized persons from dumping and analyzing its software and
assets. This page will focus on the "symmetric" cryptography involved in
the Switch's cryptosystem.

## BootROM

The Switch's BootROM does no symmetric cryptographic operations.
However, it sets up two keys in the hardware security engine's keyslots:
the SBK (Secure Boot Key) in keyslot 0xE and the SSK (Secure Storage
Key) in keyslot 0xF. Reads from both of these keyslots are disabled by
the bootROM. The material used to generate these keys is stored in
special fuses that have their access disabled by the bootROM.

The SBK is common to all consoles while the SSK is console unique. The
SSK is not used on retail devices.

## Falcon coprocessor

The falcon processor (TSEC) stores a special console-unique key (that
will be referred to as the "device keyblob seed generation key") in
fuses that only microcode authenticated by NVidia has access to.

## Bootloader stage 1

### Key generation

Bootloader stage 1 generates three keys: the stage 2 decryption key,
stored in keyslot 0xB; the master static key, which will be used by
stage 2 to generate all the static keys, stored in keyslot 0xC; and the
master device key, which will be used by stage 2 to generate all the
device-specific keys, stored in keyslot 0xD. Keyslot 0xB is cleared
after it is used to decrypt the stage 2 bootloader; only keyslots 0xC
and 0xD will be transferred to stage 2. Additionally, keyslots 0xC and
0xD are set read-only after they are generated. The SBK and the SSK are
also cleared after use (although the SSK isn't used at all, except on
dev units).

The master static key is generated by decrypting the master static seed
(a constant stored in bootloader .data) with the master static key
encryption key. The master static seed used varies depending on whether
the console is a retail unit or a dev unit. Both the master static key
encryption key and the stage 2 key are stored in a keyblob. The
following table describes the keyblob format.

| Offset | Size | Description                       |
| ------ | ---- | --------------------------------- |
| 0x0    | 0x10 | AES-CMAC over the next 0xA0 bytes |
| 0x10   | 0x10 | CTR                               |
| 0x20   | 0x90 | Encrypted keydata                 |

Decrypted Keydata format:

| Offset | Size | Description                                |
| ------ | ---- | ------------------------------------------ |
| 0x0    | 0x80 | Array of master static key encryption keys |
| 0x80   | 0x10 | Stage 2 key                                |

32 of these blobs are stored in the eMMC. Only one at a time is loaded,
it is controlled by the bootloader version field in the BCT (at
+0x2330).

Although the keydata is presumably common to all consoles, each keyblob
is console-unique, because the key used to encrypt it is at the factory
is console unique. Each keyblob has its own encryption key, with keyblob
key N generated by decrypting keyblob key seed N with the SBK, and
keyblob key seed N generated by decrypting keyblob N's seed constant
with the device keyblob seed generation key obtained from the Falcon.
Keyblob key 1 is special: In addition to being used to decrypt keyblob
1, it is also used to generate the master device key by decrypting a
constant block.

The key used to verify a keyblob's MAC is not the keyblob key but a key
derived from it; this is likely part of an attempt to mitigate
side-channel attacks as the MAC is an alterable part of the keyblob.

The bootloader only stores the seed constants for the keyblob loaded by
the current revision and for keyblob 1 (So that the master device key
can be generated).

This mechanism provides several advantages. If the stage 2 bootloader is
compromised, stage 1 can just use another master static key in the
keyblob. If stage 1 itself is glitched or exploited in such a way the
keyblob is dumped, Nintendo just has to change the loaded keyblob: the
vulnerable bootloader won't be able to decrypt the new keyblob, as the
keyblob key it knows is different from the one needed. Even if somehow
an exploit or glitch allowed one to be able to use the SBK to generate
keyblob keys, the seed constants for future keyblobs are unknown (and
will be until Nintendo releases new bootloaders that use them), and so
the exploit or glitch would have to be re-done on each new bootloader
revision (if it's not patched).

#### Summary of key derivations

The device keyblob seed generation key is unique to each device and
obtained from the Falcon. It is used to generate one or several of the
keyblob key seeds by decrypting keybloob's seed constants. The keyblob
key seeds are decrypted by the SBK to create the keyblob keys. Each
keyblob key is used to decrypt its associated keyblob's keydata, and the
keyblob key for the first keyblob is additionally used to generate the
master device key. Each keyblob stores 8 master static key encryption
keys, and the stage 2 bootloader decryption key. The master static key
is generated by decrypting the master static key seed (one of two
constants depending on retail or dev unit) with the master static key
encryption key.

### Step by step generation code

  - Falcon microcode is loaded, the device keyblob seed generation key
    is obtained from the Falcon.
  - The device keyblob seed generation key is stored in keyslot 0xD.
  - \[3.0.0+\] keyblob key seed 1 is generated by decrypting the keyblob
    seed constant 1 with the device keyblob seed generation key
  - \[3.0.0+\] keyblob key 1 is generated by decrypting keyblob key seed
    1 with the SBK. The result is directly stored in keyslot 0xA without
    leaving the crypto engine.
  - keyblob key seed N is generated by decrypting the keyblob seed
    constant N with the device keyblob seed generation key
  - keyblob key N is generated by decrypting keyblob key seed N with the
    SBK. The result is directly stored in keyslot 0xD without leaving
    the crypto engine.
  - The SBK and the SSK are cleared.
  - The constant MAC key generator block is decrypted with keyblob key N
    to generate keyblob MAC key N. The result is directly stored in
    keyslot 0xB without leaving the crypto engine.
  - With keyblob MAC key N, AES CMAC is performed over the keyblob.
  - With a comparison function which is safe against timing attacks, the
    CMAC is compared with the stored CMAC. If they differ, panic is
    called.
  - The keyblob data is decrypted with AES-CTR, using the keyblob key N
    and the stored CTR.
  - The stage 2 decryption key (the ninth key in the blob) is loaded in
    keyslot 0xB.
  - The master static key encryption key. is loaded in keyslot 0xC.
  - The decrypted keyblob data is erased.
  - The master static key is generated by decrypting the master static
    seed with the master static key encryption key. The result is
    directly stored in keyslot 0xC without leaving the crypto engine.
  - \[1.0.0-2.3.0\] The master device key is generated by decrypting a
    constant block with keyslot 0xD (which contains keyblob N's key 1).
    The result is directly stored in keyslot 0xD without leaving the
    crypto engine.
  - \[3.0.0+\] The master device key is generated by decrypting a
    constant block with keyslot 0xA (which contains keyblob 1's key 1).
    The result is directly stored in keyslot 0xD without leaving the
    crypto engine.
  - \[3.0.0+\] Keyslot 0xA is
cleared.

#### Table of used keyblobs

| System version | Used keyblob | Used master static key encryption key in keyblob |
| -------------- | ------------ | ------------------------------------------------ |
| 1.0.0-2.3.0    | 1            | 1                                                |
| 3.0.0          | 2            | 1                                                |

## Bootloader stage 2

It is currently unknown what key generation the stage 2 bootloader does.

## Secure world (TrustZone) software

The Secure world software performs all runtime cryptographic operations.

It is currently unknown what operations the Secure world software
performs.
