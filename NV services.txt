The Switch makes use of a customized NVIDIA driver.

= nvdrv:a =
Main NVIDIA driver service.

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 0 || [[#Open]]
|-
| 1 || [[#Ioctl]]
|-
| 2 || [[#Close]]
|-
| 3 || [[#Initialize]]
|-
| 4 || QueryEvent
|-
| 5 || MapSharedMem
|-
| 6 || ?
|-
| 7 || ?
|-
| 8 || BindDisplayService
|-
| 9 || ?
|}

== Open ==
{| class="wikitable" border="1"
|-
! Word || Value
|-
| 0 || 0x00100004
|-
| 1 || 0x00000008
|-
| 2-4 || Type 5 descriptor: Device path
|- style="border-top: double"
| 0-1 || "SFCI"
|-
| 2-3 || Cmd id (0)
|}

== Ioctl ==
{| class="wikitable" border="1"
|-
! Word || Value
|-
| 0 || 0x11100004
|-
| 1 || 0x00000C0B
|-
| ? || Type 0x21 descriptor: Input buffer
|-
| ? || Type 0x22 descriptor: Output buffer
|- style="border-top: double"
| 0-1 || "SFCI"
|-
| 2-3 || Cmd id (1)
|-
| 4 || Device fd
|-
| 5 || Ioctl Cmd
|}

== Close ==
{| class="wikitable" border="1"
|-
! Word || Value
|-
| 0 || 0x00000004
|-
| 1 || 0x00000009
|- style="border-top: double"
| 0-1 || "SFCI"
|-
| 2-3 || Cmd id (2)
|-
| 4 || Device fd
|}

== Initialize ==
{| class="wikitable" border="1"
|-
! Word || Value
|-
| 0 || 0x00000004
|-
| 1 || 0x80000009
|-
| ? || Handle descriptor: Current process
|-
| ? || Handle descriptor: Shared memory mirror
|- style="border-top: double"
| 0-1 || "SFCI"
|-
| 2-3 || Cmd id (3)
|-
| 4 || Shared memory size
|}

Webkit applet creates the shared memory with perm = 0 and size 0x300000.

= Ioctls =
The ioctl number is generated with the following primitive (see Linux kernel):

 #define _IOC(inout, group, num, len) \
    (inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))

The following table contains known ioctls.

== /dev/nvhost-ctrl ==
{| class="wikitable" border="1"
! Value || Direction || Size || Description || Notes
|-
| 0xC0080014 || Inout || 8 || [[#NVHOST_IOCTL_CTRL_SYNCPT_READ]] ||
|-
| 0x40040015 || In || 4 || [[#NVHOST_IOCTL_CTRL_SYNCPT_INCR]] ||
|-
| 0xC00C0016 || Inout || 12 || [[#NVHOST_IOCTL_CTRL_SYNCPT_WAIT]] ||
|-
| 0x40080017 || In || 8 || NVHOST_IOCTL_CTRL_MODULE_MUTEX ||
|-
| 0xC0180018 || Inout || 24 || NVHOST32_IOCTL_CTRL_MODULE_REGRDWR ||
|-
| 0xC0100019 || Inout || 16 || [[#NVHOST_IOCTL_CTRL_SYNCPT_WAITEX]] ||
|-
| 0xC008001A || Inout || 8 || [[#NVHOST_IOCTL_CTRL_SYNCPT_READ_MAX]] ||
|-
| 0xC004001C || Inout || 4 || [[#NVHOST_IOCTL_CTRL_EVENT_SIGNAL]] ||
|-
| 0xC010001D || Inout || 16 || [[#NVHOST_IOCTL_CTRL_EVENT_WAIT]] ||
|-
| 0xC010001E || Inout || 16 || [[#NVHOST_IOCTL_CTRL_EVENT_WAIT_ASYNC]] ||
|-
| 0xC004001F || Inout || 4 || [[#NVHOST_IOCTL_CTRL_EVENT_REGISTER]] ||
|-
| 0xC0040020 || Inout || 4 || [[#NVHOST_IOCTL_CTRL_EVENT_UNREGISTER]] ||
|-
| 0x40080021 || In || 8 || [[#NVHOST_IOCTL_CTRL_EVENT_KILL]] ||
|}

=== NVHOST_IOCTL_CTRL_SYNCPT_READ ===
Identical to Linux driver.

  struct {
    u32 __id;      // in
    u32 __value;   // out
  };

=== NVHOST_IOCTL_CTRL_SYNCPT_INCR ===
Identical to Linux driver.

  struct {
    u32 __id;      // in
  };

=== NVHOST_IOCTL_CTRL_SYNCPT_WAIT ===
Identical to Linux driver.

  struct {
    u32 __id;          // in
    u32 __thresh;      // in
    s32 __timeout;     // in
  };

=== NVHOST_IOCTL_CTRL_SYNCPT_WAITEX ===
Identical to Linux driver.

  struct {
    u32 __id;          // in
    u32 __thresh;      // in
    s32 __timeout;     // in
    u32 __value;       // out
  };

=== NVHOST_IOCTL_CTRL_SYNCPT_READ_MAX ===
Identical to Linux driver.

  struct {
    u32 __id;      // in
    u32 __value;   // out
  };

=== NVHOST_IOCTL_CTRL_EVENT_SIGNAL ===
Signals an event. Exclusive to the Switch. 

  struct {
    u32 __event_id;      // in (ranges from 0x01 to 0x3F)
  };

=== NVHOST_IOCTL_CTRL_EVENT_WAIT ===
Waits on an event. Exclusive to the Switch. 

  struct {
    u32 __unk0;         // in
    u32 __unk1;         // in
    s32 __timeout;      // in
    u32 __event;        // inout (in=event_id; out=result)
  };

=== NVHOST_IOCTL_CTRL_EVENT_WAIT_ASYNC ===
Waits on an event (async version). Exclusive to the Switch. 

  struct {
    u32 __unk0;         // in
    u32 __unk1;         // in
    s32 __timeout;      // in
    u32 __event;        // inout (in=event_id; out=result)
  };

=== NVHOST_IOCTL_CTRL_EVENT_REGISTER ===
Registers an event. Exclusive to the Switch. 

  struct {
    u32 __event_id;      // in (ranges from 0x01 to 0x3F)
  };

=== NVHOST_IOCTL_CTRL_EVENT_UNREGISTER ===
Unregisters an event. Exclusive to the Switch. 

  struct {
    u32 __event_id;      // in (ranges from 0x01 to 0x3F)
  };

=== NVHOST_IOCTL_CTRL_EVENT_KILL ===
Kills events. Exclusive to the Switch. 

  struct {
    u64 __events;      // in (64-bit flag where each bit represents one event)
  };

== /dev/nvhost-as-gpu ==
Each fd opened to this device creates an address space. An address space is then later bound with a channel.

Once a nvgpu channel has been bound to an address space it cannot be unbound. There is no support for allowing an nvgpu channel to change from one address space to another (or from one to none).
                                                                                                                              
{| class="wikitable" border="1"
! Value || Direction || Size || Description || Notes
|-
| 0x40044101 || In || 4 || [[#NVGPU_AS_IOCTL_BIND_CHANNEL]] ||
|-
| 0xC0184102 || Inout || 24 || [[#NVGPU_AS_IOCTL_ALLOC_SPACE]] ||
|-
| 0xC0104103 || Inout || 16 || [[#NVGPU_AS_IOCTL_FREE_SPACE]] ||
|-
| 0xC0184104 || Inout || 24 || [[#NVGPU_AS_IOCTL_MAP_BUFFER]] ||
|-
| 0xC0084105 || Inout || 8 || [[#NVGPU_AS_IOCTL_UNMAP_BUFFER]] ||
|-
| 0xC0284106 || Inout || 40 || NVGPU_AS_IOCTL_MAP_BUFFER_EX ||
|-
| 0x40104107 || In || 16 || [[#NVGPU_AS_IOCTL_INITIALIZE]] ||
|-
| 0xC0404108 || Inout || 64 || [[#NVGPU_AS_IOCTL_GET_VA_REGIONS]] ||
|-
| 0x40284109 || In || 40 || [[#NVGPU_AS_IOCTL_INITIALIZE_EX]] ||
|-
| 0xC0144114 || Inout || 20 || ||
|}

=== NVGPU_AS_IOCTL_BIND_CHANNEL ===
Identical to Linux driver.

  struct {
    u32 __fd; // in
  };

=== NVGPU_AS_IOCTL_ALLOC_SPACE ===
This one reserves pages in the device address space.

  struct {
    u32 __pages;     // in
    u32 __page_size; // in
    u32 __flags;     // in
    u32 __pad;
    union {
      u64 __offset;  // out
      u64 __align;   // in
    };
  };

=== NVGPU_AS_IOCTL_FREE_SPACE ===
  struct {
    u64 __offset;    // in
    u32 __pages;     // in
    u32 __page_size; // in
  };

=== NVGPU_AS_IOCTL_MAP_BUFFER ===
Map a memory region in the device address space. Identical to Linux driver pretty much.

On success, the mapped memory region is locked by having [[SVC#MemoryState]] bit34 set.

  struct {
    u32 __flags;        // in, 4 works
    u32 __reserved;
    u32 __nvmap_handle; // in
    u32 __page_size;    // inout, 0 means don't care
    union {
      u64 __offset;     // out
      u64 __align;      // in
    };
  };

=== NVGPU_AS_IOCTL_UNMAP_BUFFER ===
Doesn't do shit.

=== NVGPU_AS_IOCTL_INITIALIZE ===
Nintendo's custom implementation of NVGPU_GPU_IOCTL_ALLOC_AS (unavailable).

  struct {
    u32 __big_page_size;   // in (depends on GPU's available_big_page_sizes; 0=default)
    s32 __as_fd;           // in (ignored; passes 0)
    u32 __flags;           // in (ignored; passes 0)
    u32 __reserved;        // in (ignored; passes 0)
  };

=== NVGPU_AS_IOCTL_GET_VA_REGIONS ===
Nintendo modified to get rid of pointer in struct.

  struct va_region {
    u64 __offset;
    u32 __page_size;
    u32 __reserved;
    u64 __pages;
  };
  
  struct {
    u64              __not_used;   // (contained output user ptr on linux, ignored)
    u32              __bufsize;    // inout, forced to 2*sizeof(struct va_region)
    u32              __reserved;
    struct va_region __regions[2]; // out
  };

=== NVGPU_AS_IOCTL_INITIALIZE_EX ===
Nintendo's custom implementation of NVGPU_GPU_IOCTL_ALLOC_AS (unavailable) with extra params.

  struct {
    u32 __big_page_size;   // in (depends on GPU's available_big_page_sizes; 0=default)
    s32 __as_fd;           // in (ignored; passes 0)
    u32 __flags;           // in (ignored; passes 0)
    u32 __reserved;        // in (ignored; passes 0)
    u64 __unk0;            // in
    u64 __unk1;            // in
    u64 __unk2;            // in
  };

== /dev/nvmap ==
{| class="wikitable" border="1"
! Value || Direction || Size || Description || Notes
|-
| 0xC0080101 || Inout || 8 || [[#NVMAP_IOC_CREATE]] ||
|-
| 0x00000102 || - || 0 || NVMAP_IOC_CLAIM || Returns NotSupported
|-
| 0xC0080103 || Inout || 8 || [[#NVMAP_IOC_FROM_ID]] ||
|-
| 0xC0200104 || Inout || 32 || [[#NVMAP_IOC_ALLOC]] ||
|-
| 0xC0180105 || Inout || 24 || [[#NVMAP_IOC_FREE]] ||
|-
| 0xC0280106 || Inout || 40 || NVMAP_IOC_MMAP || Returns NotSupported
|-
| 0xC0280107 || Inout || 40 || NVMAP_IOC_WRITE || Returns NotSupported
|-
| 0xC0280108 || Inout || 40 || NVMAP_IOC_READ || Returns NotSupported
|-
| 0xC00C0109 || Inout || 12 || [[#NVMAP_IOC_PARAM]] ||
|-
| 0xC010010A || Inout || 16 || NVMAP_IOC_PIN_MULT || Returns NotSupported
|-
| 0xC010010B || Inout || 16 || NVMAP_IOC_UNPIN_MULT || Returns NotSupported
|-
| 0xC008010C || Inout || 8 || NVMAP_IOC_CACHE || Returns NotSupported
|-
| 0xC004010D || Inout || 4 || || Returns NotSupported
|-
| 0xC008010E || Inout || 8 || [[#NVMAP_IOC_GET_ID]] ||
|-
| 0xC004010F || Inout || 4 || || Returns NotSupported
|-
| 0x40040110 || In || 4 || || Returns NotSupported
|-
| 0x00000111 || - || 0 || || Returns NotSupported
|}

=== NVMAP_IOC_CREATE ===
Creates an nvmap object. Identical to Linux driver.

  struct {
    u32 __size;   // in
    u32 __handle; // out
  };

=== NVMAP_IOC_FROM_ID ===
Get handle to an existing nvmap object. Identical to Linux driver.

  struct {
    u32 __id;     // in
    u32 __handle; // out
  };

=== NVMAP_IOC_ALLOC ===
Allocate memory for the nvmap object. Nintendo extended this one with 16 bytes, and changed it from in to inout.

  struct {
    u32 __handle;   // in
    u32 __heapmask; // in
    u32 __flags;    // in (0=read-only, 1=read-write)
    u32 __align;    // in
    u8  __kind;     // in
    u8  __pad[7];
    u64 __addr;     // in
  };

=== NVMAP_IOC_FREE ===
This one is completely custom. Partly because the Linux driver passed the handle as the ioctl "arg-ptr", and HIPC can't handle that voodoo.

  struct {
    u32 __handle;   // in
    u32 __pad;
    u64 __refcount; // out
    u32 __size;     // out
    u32 __flags;    // out, 1=NOT_FREED_YET
  };

=== NVMAP_IOC_PARAM ===
Returns info about a nvmap object. Identical to Linux driver, but extended with further params.

  struct {
    u32 __handle; // in
    u32 __param;  // in, 1=SIZE, 2=ALIGNMENT, 3=BASE (returns error), 4=HEAP (always 0x40000000), 5=KIND, 6=COMPR (unused)
    u32 __result; // out
  };

=== NVMAP_IOC_GET_ID ===
Returns an id for a nvmap object. Identical to Linux driver.

  struct {
    u32 __id;     // out
    u32 __handle; // in
  };

== /dev/nvhost-ctrl-gpu ==
This device is for global (context independent) operations on the gpu.  
                                                                                                                                               
{| class="wikitable" border="1"
! Value || Direction || Size || Description || Notes
|-
| 0x80044701 || Out || 4 || NVGPU_GPU_IOCTL_ZCULL_GET_CTX_SIZE ||
|-
| 0x80284702 || Out || 40 || NVGPU_GPU_IOCTL_ZCULL_GET_INFO ||
|-
| 0x402C4703 || In || 44 || NVGPU_GPU_IOCTL_ZBC_SET_TABLE ||
|-
| 0xC0344704 || Inout || 52 || NVGPU_GPU_IOCTL_ZBC_QUERY_TABLE ||
|-
| 0xC0B04705 || Inout || 176 || [[#NVGPU_GPU_IOCTL_GET_CHARACTERISTICS]] ||
|-
| 0xC0184706 || Inout || 24 || NVGPU_GPU_IOCTL_GET_TPC_MASKS ||
|-
| 0x40084707 || In || 8 || [[#NVGPU_GPU_IOCTL_FLUSH_L2]] ||
|-
| 0x4008470E || In || 8 || ||
|-
| 0x4010470F || In || 16 || ||
|-
| 0xC0084710 || Inout || 8 || ||
|-
| 0x80084711 || Out || 8 || ||
|-
| 0x80084712 || Out || 8 || ||
|-
| 0xC0044713 || Inout || 4 || ||
|-
| 0x80084714 || Out || 8 || [[#NVGPU_GPU_IOCTL_GET_L2_STATE]] ||
|-
| 0x80044715 || Out || 4 || ||
|-
| 0x8018471A || Out || 24 || ||
|-
| 0xC008471B || Inout || 8 || ||
|-
| 0xC010471C || Inout || 16 || ||
|}

=== NVGPU_GPU_IOCTL_GET_CHARACTERISTICS ===
Returns the GPU characteristics. Modified to return inline data instead of using a pointer.

  struct __gpu_characteristics {
    u32 __arch;                           // 0x120 (NVGPU_GPU_ARCH_GM200)
    u32 __impl;                           // 0xB (NVGPU_GPU_IMPL_GM20B)
    u32 __rev;                            // 0xA1 (Revision A1)
    u32 __num_gpc;                        // 0x1
    u64 __L2_cache_size;                  // 0x40000
    u64 __on_board_video_memory_size;     // 0x0 (not used)
    u32 __num_tpc_per_gpc;                // 0x2
    u32 __bus_type;                       // 0x20 (NVGPU_GPU_BUS_TYPE_AXI)
    u32 __big_page_size;                  // 0x20000
    u32 __compression_page_size;          // 0x20000
    u32 __pde_coverage_bit_count;         // 0x1B
    u32 __available_big_page_sizes;       // 0x30000
    u32 __gpc_mask;                       // 0x1
    u32 __sm_arch_sm_version;             // 0x503 (Maxwell Generation 5.0.3?)
    u32 __sm_arch_spa_version;            // 0x503 (Maxwell Generation 5.0.3?)
    u32 __sm_arch_warp_count;             // 0x80
    u32 __gpu_va_bit_count;               // 0x28
    u32 __reserved;                       // NULL
    u64 __flags;                          // 0x55
    u32 __twod_class;                     // 0x902D (FERMI_TWOD_A)
    u32 __threed_class;                   // 0xB197 (MAXWELL_B)
    u32 __compute_class;                  // 0xB1C0 (MAXWELL_COMPUTE_B)
    u32 __gpfifo_class;                   // 0xB06F (MAXWELL_CHANNEL_GPFIFO_A)
    u32 __inline_to_memory_class;         // 0xA140 (KEPLER_INLINE_TO_MEMORY_B)
    u32 __dma_copy_class;                 // 0xB0B5 (MAXWELL_DMA_COPY_A)
    u32 __max_fbps_count;                 // 0x1
    u32 __fbp_en_mask;                    // 0x0 (disabled)
    u32 __max_ltc_per_fbp;                // 0x2
    u32 __max_lts_per_ltc;                // 0x1
    u32 __max_tex_per_tpc;                // 0x0 (not supported)
    u32 __max_gpc_count;                  // 0x1
    u32 __rop_l2_en_mask_0;               // 0x21D70 (fuse_status_opt_rop_l2_fbp_r)
    u32 __rop_l2_en_mask_1;               // 0x0
    u64 __chipname;                       // 0x6230326D67 ("gm20b")
    u64 __gr_compbit_store_base_hw;       // 0x0 (not supported)
  };
 
  struct {
    u64 __gpu_characteristics_buf_size;   // in/out (must not be NULL, but gets overwritten with 0xA0=max_size)
    u64 __gpu_characteristics_buf_addr;   // in (ignored, but must not be NULL)
    struct __gpu_characteristics gc;      // out
  };

=== NVGPU_GPU_IOCTL_FLUSH_L2 ===
Flushes the GPU L2 cache.

  struct {
    u32 __flush;          // in (l2_flush | l2_invalidate << 1 | fb_flush << 2)
    u32 __reserved;       // in
  };

=== NVGPU_GPU_IOCTL_GET_L2_STATE ===
Returns the GPU L2 cache state.

  struct {
    u32 __mask;        // out (always 0x07)
    u32 __flush;       // out (active flush bit field)
  };

== Channels ==
Channels are a concept for  NVIDIA hardware blocks that share a common interface.

{| class="wikitable" border="1"
! Path || Name
|-
| /dev/nvhost-gpu ||
|-
| /dev/nvhost-vic || Video Image Compositor
|-
| /dev/nvhost-nvdec || Video Decoder
|-
| /dev/nvhost-nvjpg || JPEG Decoder
|}

== Channel Ioctls ==
{| class="wikitable" border="1"
! Value || Size || Description || Notes
|-
| 0xC0??0001 || Variable || NVHOST_IOCTL_CHANNEL_SUBMIT ||
|-
| 0xC0080002 || 8 || NVHOST_IOCTL_CHANNEL_GET_SYNCPOINT ||
|-
| 0xC0080003 || 8 || NVHOST_IOCTL_CHANNEL_GET_WAITBASE ||
|-
| 0xC0080004 || 8 || NVHOST_IOCTL_CHANNEL_SET_TIMEOUT_EX ||
|-
| 0x40040007 || 4 || ||
|-
| 0xC0??0009 || Variable || NVHOST_IOCTL_CHANNEL_MAP_BUFFER ||
|-
| 0xC0??000A || Variable || NVHOST_IOCTL_CHANNEL_UNMAP_BUFFER ||
|-
| 0x00000013 || 0 || ||
|- style="border-top: double"
| 0x40044801 || 4 || [[#NVGPU_IOCTL_CHANNEL_SET_NVMAP_FD]] ||
|-
| 0x40044803 || 4 || NVGPU_IOCTL_CHANNEL_SET_PRIORITY ||
|-
| 0x40084805 || 8 || [[#NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO]] ||
|-
| 0xC0044807 || 4 || NVGPU_IOCTL_CHANNEL_CYCLE_STATS ||
|-
| 0xC0??4808 || Variable || [[#NVGPU_IOCTL_CHANNEL_SUBMIT_GPFIFO]] ||
|-
| 0xC0104809 || 16 || [[#NVGPU_IOCTL_CHANNEL_ALLOC_OBJ_CTX]] ||
|-
| 0xC010480B || 16 || NVGPU_IOCTL_CHANNEL_ZCULL_BIND ||
|-
| 0xC018480C || 24 || [[#NVGPU_IOCTL_CHANNEL_SET_ERROR_NOTIFIER]] ||
|-
| 0x4004480D || 4 || [[#NVGPU_IOCTL_CHANNEL_OPEN]] ||
|-
| 0x0000480E || 0 || [[#NVGPU_IOCTL_CHANNEL_ENABLE]] ||
|-
| 0x0000480F || 0 || [[#NVGPU_IOCTL_CHANNEL_DISABLE]] ||
|-
| 0x00004810 || 0 || [[#NVGPU_IOCTL_CHANNEL_PREEMPT]] ||
|-
| 0x00004811 || 0 || [[#NVGPU_IOCTL_CHANNEL_FORCE_RESET]] ||
|-
| 0x40084812 || 8 || [[#NVGPU_IOCTL_CHANNEL_EVENTS_CTRL]] ||
|-
| 0xC0104813 || 16 || NVGPU_IOCTL_CHANNEL_CYCLE_STATS_SNAPSHOT ||
|-
| 0x80804816 || 128 || || Only works when the channel is busy
|-
| 0xC0104817 || 16 || [[#NVGPU_IOCTL_CHANNEL_GET_ERROR]] ||
|-
| 0x40204818 || 32 || [[#NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO_EX]] ||
|-
| 0xC0??4819 || Variable || [[#NVGPU_IOCTL_CHANNEL_SUBMIT_GPFIFO_EX]] ||
|-
| 0xC020481A || 32 || [[#NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO_EX2]] ||
|-
|- style="border-top: double"
| 0x40084714 || 8 || set_user_address || Sets an unknown user context address
|-
| 0x80084715 || 8 || get_user_address || Gets an unknown user context address
|}

=== NVGPU_IOCTL_CHANNEL_SET_NVMAP_FD ===
Binds a nvmap object to this channel. Identical to Linux driver.

  struct {
    u32 __nvmap_fd;     // in
  };

=== NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO ===
Allocates gpfifo entries. Identical to Linux driver.

  struct {
    u32 __num_entries;     // in
    u32 __flags;           // in
  };

=== NVGPU_IOCTL_CHANNEL_SUBMIT_GPFIFO ===
Submits a gpfifo object. Modified to take inline entry objects instead of a pointer.

  struct fence {
    u32 __id;
    u32 __value;
  };
  
  struct gpfifo_entry {
    u32 __entry0;
    u32 __entry1;
  };
  
  struct {
    u64 __gpfifo;                     // in (pointer to gpfifo fence structs; ignored)
    u32 __num_entries;                // in (number of fence objects being submitted)
    u32 __flags;                      // in
    struct fence        __fence_out;  // out (returned new fence object for others to wait on)
    struct gpfifo_entry __entries[];  // in (depends on __num_entries)
  };

=== NVGPU_IOCTL_CHANNEL_ALLOC_OBJ_CTX ===
Allocates a graphics context object. Modified to ignore object's ID.

  struct {
    u32 __class_num;    // in (0x902D=2d, 0xB197=3d, 0xB1C0=compute, 0xA140=kepler, 0xB0B5=DMA, 0xB06F=channel_gpfifo)
    u32 __flags;        // in
    u64 __obj_id;       // out (ignored; used for FREE_OBJ_CTX ioctl, which is not supported)
  };

=== NVGPU_IOCTL_CHANNEL_SET_ERROR_NOTIFIER ===
Initializes the error notifier for this channel. Identical to Linux driver.

  struct {
    u64 __offset;    // in
    u64 __size;      // in
    u32 __mem;       // in (nvmap object handle)
    u32 __padding;   // in
  };

=== NVGPU_IOCTL_CHANNEL_OPEN ===
Opens the current channel. Unused and takes an unknown argument.

  struct {
    u32 __unk;    // in (only accepts 0x32, 0x64 or 0x96)
  };

=== NVGPU_IOCTL_CHANNEL_ENABLE ===
Enables the current channel. Identical to Linux driver.

=== NVGPU_IOCTL_CHANNEL_DISABLE ===
Disables the current channel. Identical to Linux driver.

=== NVGPU_IOCTL_CHANNEL_PREEMPT ===
Clears the FIFO pipe for this channel. Identical to Linux driver.

=== NVGPU_IOCTL_CHANNEL_FORCE_RESET ===
Forces the channel to reset. Identical to Linux driver.

=== NVGPU_IOCTL_CHANNEL_EVENTS_CTRL ===
Controls event notifications. Modified to take an additional argument.

  struct {
    u32 __cmd;    // in (0=disable, 1=enable, 2=clear)
    u32 __unk;    // in (accepts 1 or 2)
  };

=== NVGPU_IOCTL_CHANNEL_GET_ERROR ===
Returns the current error notification caught by the error notifier. Exclusive to the Switch.

  struct {
    u64 __timestamp;    // out (nanoseconds since Jan. 1, 1970)
    u32 __info32;       // out (error code)
    u16 __info16;       // out (additional error info)
    u16 __status;       // inout (always 0xFFFF)
  };

=== NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO_EX ===
Allocates gpfifo entries with additional parameters. Exclusive to the Switch.

  struct {
    u32 __num_entries;     // in
    u32 __flags;           // in
    u32 __unk0;            // in (1 works)
    u32 __unk1;            // in
    u32 __unk2;            // in
    u32 __unk3;            // in
    u32 __unk4;            // in
    u32 __unk5;            // in
  };

=== NVGPU_IOCTL_CHANNEL_SUBMIT_GPFIFO_EX ===
Submits a gpfifo object (async version). Exclusive to the Switch.

  struct {
    u64 __gpfifo;                     // in (pointer to gpfifo fence structs; ignored)
    u32 __num_entries;                // in (number of fence objects being submitted)
    u32 __flags;                      // in
    struct fence        __fence_out;  // out (returned new fence object for others to wait on)
    struct gpfifo_entry __entries[];  // in (depends on __num_entries)
  };

=== NVGPU_IOCTL_CHANNEL_ALLOC_GPFIFO_EX2 ===
Allocates gpfifo entries with additional parameters and returns a fence. Exclusive to the Switch.
 
  struct {
    u32 __num_entries;         // in
    u32 __flags;               // in
    u32 __unk0;                // in (1 works)
    struct fence __fence_out;  // out
    u32 __unk1;                // in
    u32 __unk2;                // in
    u32 __unk3;                // in
  };

== Remaining Ioctls ==
Not accessible, but there is code to invoke them.

{| class="wikitable" border="1"
! Value || Size || Description || Notes
|-
| /dev/nvhost-dbg-gpu || 0x40084401 || NVGPU_DBG_GPU_IOCTL_BIND_CHANNEL ||
|-
| /dev/nvhost-dbg-gpu || 0xC0??4402 || NVGPU_DBG_GPU_IOCTL_REG_OPS || ?? == size is unknown
|-
| /dev/nvhost-dbg-gpu || 0x40084403 || NVGPU_DBG_GPU_IOCTL_EVENTS_CTRL ||
|-
| /dev/nvhost-dbg-gpu || 0x40044404 || NVGPU_DBG_GPU_IOCTL_POWERGATE ||
|-
| /dev/nvhost-dbg-gpu || 0x40044405 || NVGPU_DBG_GPU_IOCTL_SMPC_CTXSW_MODE ||
|-
| /dev/nvhost-dbg-gpu || 0xC0184407 || NVGPU_DBG_GPU_IOCTL_PERFBUF_MAP ||
|-
| /dev/nvhost-dbg-gpu || 0x40084408 || NVGPU_DBG_GPU_IOCTL_PERFBUF_UNMAP ||
|-
| /dev/nvhost-dbg-gpu || 0x40084409 || NVGPU_DBG_GPU_IOCTL_PC_SAMPLING ||
|-
|}

= nvmemp =
NVIDIA memory profiler (this service is not available on retail units).

= mm:u =
NVIDIA multimedia (NvMM) platform service.

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 0 || ?
|-
| 1 || ?
|-
| 2 || ?
|-
| 3 || ?
|-
| 4 || module_init_clk
|-
| 5 || module_deinit_clk
|-
| 6 || module_set_clk_rate
|-
| 7 || module_get_clk_rate
|}

= Errors =
Most nvidia driver commands return an error code apart from the normal return code.

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 0 || Success
|-
| 1 || NotImplemented
|-
| 2 || NotSupported
|-
| 3 || NotInitialized
|-
| 4 || BadParameter
|-
| 5 || Timeout
|-
| 6 || InsufficientMemory
|-
| 7 || ReadOnlyAttribute
|-
| 8 || InvalidState
|-
| 9 || InvalidAddress
|-
| 0xA || InvalidSize
|-
| 0xB || BadValue
|-
| 0xD || AlreadyAllocated
|-
| 0xE || Busy
|-
| 0xF || ResourceError
|-
| 0x10 || CountMismatch
|-
| 0x1000 || SharedMemoryTooSmall
|-
| 0x30003 || FileOperationFailed
|-
| 0x3000F || IoctlFailed                        
|}

[[Category:Services]]