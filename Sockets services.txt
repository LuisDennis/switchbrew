= bsd:u / bsd:s =
This is "nn::socket::sf::IClient".

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 0  || RegisterClient (Initialize)
|-
| 1  || StartMonitoring
|-
| 2  || Socket
|-
| 3  || SocketExempt
|-
| 4  || Open
|-
| 5  || Select
|-
| 6  || Poll
|-
| 7  || Sysctl
|-
| 8  || Recv
|-
| 9  || RecvFrom
|-
| 10 || Send
|-
| 11 || SendTo
|-
| 12 || Accept
|-
| 13 || Bind
|-
| 14 || Connect
|-
| 15 || GetPeerName
|-
| 16 || GetSockName
|-
| 17 || GetSockOpt
|-
| 18 || Listen
|-
| 19 || Ioctl
|-
| 20 || Fcntl
|-
| 21 || SetSockOpt
|-
| 22 || Shutdown
|-
| 23 || ShutdownAllSockets
|-
| 24 || Write
|-
| 25 || Read
|-
| 26 || Close
|-
| 27 || DuplicateSocket
|-
| 28 || GetResourceStatistics
|-
| 29 || [3.0.0+] RecvMMsg
|-
| 30 || [3.0.0+] SendMMsg
|}

Open: can open <code>/dev/bpf</code> (and most likely only that file, given bsdservices' binary contents). This can be used, for example, to enable promiscuous mode, see FreeBSD's <code>/dev/bpf</code> for more details.

== Initalize ==

Takes a [[#BsdBufferConfig]] (made-up name), the PID, the size of the transfer memory and a copy-handle of the latter.

=== BsdBufferConfig ===

 /// Configuration structure for bsdInitalize
 typedef struct  {
     u32 version;                ///< Observed 1 on 2.0 LibAppletWeb, 2 on 3.0.
 
     u32 tcp_tx_buf_size;        ///< Size of the TCP transfer (send) buffer (initial or fixed).
     u32 tcp_rx_buf_size;        ///< Size of the TCP recieve buffer (initial or fixed).
     u32 tcp_tx_buf_max_size;    ///< Maximum size of the TCP transfer (send) buffer. If it is 0, the size of the buffer is fixed to its initial value.
     u32 tcp_rx_buf_max_size;    ///< Maximum size of the TCP receive buffer. If it is 0, the size of the buffer is fixed to its initial value.
 
     u32 udp_tx_buf_size;        ///< Size of the UDP transfer (send) buffer (typically 0x2400 bytes).
     u32 udp_rx_buf_size;        ///< Size of the UDP receive buffer (typically 0xA500 bytes).
 
     u32 sb_efficiency;          ///< Number of buffers for each socket (standard values range from 1 to 8).
 } BsdBufferConfig;


The transfer memory must be larger than a the computed size below. Should the transfer memory be smaller than that, the BSD sockets service would only send ZeroWindow packets (for TCP), resulting in a transfer rate not exceeding 1 byte/s.

 static size_t _bsdGetTransferMemSizeForConfig(const BsdConfig *config)
 {
     u32 tcp_tx_buf_max_size = config->tcp_tx_buf_max_size != 0 ? config->tcp_tx_buf_max_size : config->tcp_tx_buf_size;
     u32 tcp_rx_buf_max_size = config->tcp_rx_buf_max_size != 0 ? config->tcp_rx_buf_max_size : config->tcp_rx_buf_size;
     u32 sum = tcp_tx_buf_max_size + tcp_rx_buf_max_size + config->udp_tx_buf_size + config->udp_rx_buf_size;
 
     sum = ((sum + 0xFFF) >> 12) << 12; // page round-up
     return (size_t)(config->sb_efficiency * sum);
 }

= sfdnsres =
This is "nn::socket::resolver::IResolver".

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 0 || SetDnsAddressesPrivate
|-
| 1 || GetDnsAddressPrivate
|-
| 2 || GetHostByName
|-
| 3 || GetHostByAddr
|-
| 4 || GetHostStringError
|-
| 5 || GetGaiStringError
|-
| 6 || [[#GetAddrInfo]]
|-
| 7 || GetNameInfo
|-
| 8 || RequestCancelHandle
|-
| 9 || CancelSocketCall
|}

=== GetAddrInfo ===

Takes three type 5 buffers (host, port, and hints), and a type 6 buffer (the output addrinfos). Also takes a u8 (padded to 4 bytes so the next raw parameter can align), a u32, and a u64. The u8 is a boolean for whether to enable "nsd resolve" (1) or not (0). Not sure what the u32 is. It seems to either come from a parameter to <tt>GetAddrInfo</tt> or be zero. The u64 is most likely a placeholder for the server to copy the PID into and should be zero. Both hints and the output buffer contain serialized addrinfo chains. The hints buffer is sized 0x400 bytes long by default, and the output buffer 0x1000 bytes.

=== Addrinfo Serialization Format ===

Each struct addrinfo in the linked list is serialized according to this format and then written to the buffer. All numbers are in network byte order.

{| class="wikitable" border="1"
|-
! Size (bytes) || Name || Notes
|-
| 4 || Magic || Needs to be 0xBEEFCAFE. Seriously.
|-
| 4 || ai_flags ||
|-
| 4 || ai_family ||
|-
| 4 || ai_socktype ||
|-
| 4 || ai_protocol ||
|-
| 4 || ai_addrlen ||
|-
| ai_addrlen ? ai_addrlen : 4 || ai_addr ||
|-
| null-terminated string || ai_canonname ||
|}

If <tt>ai_addrlen</tt> is zero, <tt>ai_addr</tt> will occupy 4 bytes.

{| class="wikitable" border="1"
|-
! Size (bytes) || Name || Notes
|-
| 4 || ai_addr
|}

If <tt>ai_family</tt> is recognized as AF_INET6 (28) or AF_INET (2), <tt>ai_addr</tt> is read as <tt>struct sockaddr_in</tt> or <tt>struct sockaddr_in6</tt>. Otherwise, it's just read as <tt>u8[ai_addrlen]</tt>.

The list should be terminated with a sentinel four-byte zero value.

= nsd:u / nsd:a =
This is "nn::nsd::detail::IManager".

{| class="wikitable" border="1"
|-
! Cmd || Name
|-
| 10 || GetSettingName
|-
| 11 || GetEnvironmentIdentifier
|-
| 12 || GetDeviceId
|-
| 13 || DeleteSettings
|-
| 14 || ImportSettings
|-
| 20 || Resolve
|-
| 21 || ResolveEx
|-
| 30 || GetNasServiceSetting
|-
| 31 || GetNasServiceSettingEx
|-
| 40 || GetNasRequestFqdn
|-
| 41 || GetNasRequestFqdnEx
|-
| 42 || GetNasApiFqdn
|-
| 43 || GetNasApiFqdnEx
|-
| 50 || GetCurrentSetting
|-
| 60 || ReadSaveDataFromFsForTest
|-
| 61 || WriteSaveDataToFsForTest
|-
| 62 || DeleteSaveDataOfFsForTest
|}